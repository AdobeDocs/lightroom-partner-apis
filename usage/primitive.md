# Primitive Data Types

This page describes data types whose definitions may not be commonly recognized. Unless otherwise stated, these are expressed as strings in the JSON content traversing the Lightroom APIs.

## Lowercase UUID

A <a target="new" href="http://en.wikipedia.org/wiki/Universally_unique_identifier"> universally-unique identifier</a> where the hex digits are represented using lower case letters and the hyphens are omitted. Used to identify virtually all objects in the Lightroom cloud.

## User-visible string

A *user-visible string* is interpreted to mean any string that is valid in JSON, with the following exceptions:

* UTF8 encoding is expected.
* Unicode control characters (including CR, LF, tab) are disallowed.
* Clients are expected to display these as user-visible strings without further interpretation. Clients are responsible for escaping strings to prevent unwanted interpretations.
* This is specifically **not** formatted HTML. Any HTML markup that might be entered into the string should **not** cause the corresponding HTML formatting to occur. Clients are responsible for escaping characters such as <, >, and & to prevent browser side effects.
* User-visible strings must be non-empty.
* Some of these restrictions might be overridden in specific cases.


## ISO 8601 date stamps

An ISO 8601 date stamp, unless otherwise specified, is a timestamp in the [W3C-specific subset of the ISO 8601 format](http://www.w3.org/TR/NOTE-datetime).

* Timestamps intended for sorting should be specified in UTC and include the trailing "Z" indicator of such. Clients should use the closest available approximation of UTC. The Lightroom server will always use a highly-accurate UTC time.
* Timestamps intended for user display and grouping (especially date-based grouping) should use local timestamps and include an appropriate designator of the actual time zone.

### Cleansing Invalid Datetime Values

The datetime values provided by clients in some model payloads have validation rules. A datetime might come from metadata generated by a camera or a third party application which may be using nonstandard formatting that does not pass the validation rules. It is recommended that clients check payload values for validity before sending the data to the cloud. Specifically for datetime values, if the value does not pass validation it is recommended that clients attempt some simple fixes to the datetime to retain as much information as possible and to get to a valid value.

Validating dates locally before sending to the cloud is preferred. If the cloud rejects a date as invalid, it is recommended to remove the date or come up with a suitable replacement for required dates as detailed below, in order to avoid bugs involving confusion and disagreement between the cloud and client on the correct values, which sometimes triggers looping behavior where the client attempts to send the same data to the cloud repeatedly, in some cases thousands of times.

* If the seconds value is 60, indicating a possible leap second, convert it to 59
    * e.g. 2017-03-09T15:47:60.000Z becomes 2017-03-09T15:47:59.000Z
* Try removing the time and submitting the date only.
    * Most datetime values in the data model require time, so a client would need to replace the time with 00:00:00 (e.g. 2017-03-09T00:00:00)
    * Many times do not require timezone, but some times require a valid timezone and some specifically require GMT timezone with a Z timezone specification (e.g. 2017-03-09T00:00:00Z). For all times requiring a time zone, the recommendation is to specify GMT (Z) timezone.
    * Most datetimes in the xmp section of the asset payload allow date only (e.g. 2017-03-09)
* If the date is invalid, then a client will need to omit the field or come up with a suitable replacement for required fields.
    * The required field captureDate in the asset payload allows the special value 0000-00-00T00:00:00 for assets with unknown capture date.
    * The only other strictly required fields for assets is importSource.importTimestamp, and current time can be substituted for that value.

## Reasonable file/folder path name

A reasonable file or folder path is a UTF-8 string designed to comply with the typical file naming rules on MacOS and Windows without unexpected side effects.

## Ratio

A **ratio** is an array value consisting of one or two integer values (**numerator** and **denominator**) encoded as JSON integers. If omitted, **denominator** is assumed to be 1. There is no requirement that the fractions be reduced. Both the **numerator** and **denominator** must be integers less than or equal to 2^53 (9007199254740992). **Numerator** may be negative but greater than or equal to -2^53. **Denominator** must be greater than zero. (2^53 is the largest integer value that can be stored in a double-precision floating point "C" data type.)

<pre>
RATIO
  : '[' numerator [,  " " denominator ] ']' // denominator > 0
 
numerator | denominator
  : -?<digit>+
</pre>

Note about pixel aspect ratio: Some videos have non-square pixels. The asset width and height in the top-level asset document will be converted to square pixel dimensions. To find out the actual number of non-square-pixels wide and high the master asset is, consult the storageWidth and storageHeight fields of the video section. For example, an NTSC video stored as 720x480 (SAR 3:2) rendered as 640x480 (DAR 4:3) should have width of 640 and height of 480 in the top-level asset document.


## lex64 Sort Order Strings

The **order** string shall contain a maximum of 1024 characters in the set: `[-0-9A-Z_a-z]`. This is the same character set as "base64url" described in [RFC 4648](http://tools.ietf.org/html/rfc4648#section-5) and was chosen for its URL-safeness. It differs from base64url due to the lexicographical sort order: ("-", "0", "9", "A", "Z", "_", "a", "z").

### Workflow Details

* An object document that supports the order field will not have an `order` field until one is specified by the client.
* The absence of an `order` field will cause that object to be sorted at the end for an ascending sort, or at the beginning for a descending sort.
* The secondary sort field will be the `captureDate` date of the object (for identical or absent values).
* The tertiary sort field will be the `created` date of the object (for identical or absent captureDate values).
* Removing the `order` field from an object document is achieved by writing the JSON `null` value.
* The empty string is not a valid `order` field value.
* In order to preserve the ability to insert at the beginning of the list, the order string cannot end with the "-" character.

### Workflow Suggestions

* The algorithm for picking an `order` value that is between two existing `order` values should attempt to minimize length, to avoid hitting the order field length limit, and being forced to renumber multiple object documents.
* When the user changes the `order` of N assets in an album, in most cases only N object documents will have to be modified. The notable exception to this is when the user places an object amongst objects without an `order` field; in that case many object documents will have to be modified in order to achieve the desired ordering.
